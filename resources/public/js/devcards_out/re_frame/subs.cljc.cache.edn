;; Analyzed by ClojureScript 1.8.40
{:use-macros nil, :excludes #{}, :name re-frame.subs, :imports nil, :requires {re-frame.db re-frame.db, re-frame.interop re-frame.interop, re-frame.loggers re-frame.loggers, re-frame.utils re-frame.utils, re-frame.registrar re-frame.registrar}, :uses {console re-frame.loggers, app-db re-frame.db, add-on-dispose! re-frame.interop, make-reaction re-frame.interop, get-handler re-frame.registrar, first-in-vector re-frame.utils, deref? re-frame.interop, ratom? re-frame.interop, debug-enabled? re-frame.interop, clear-handlers re-frame.registrar, register-handler re-frame.registrar}, :defs {kind {:name re-frame.subs/kind, :file "resources/public/js/devcards_out/re_frame/subs.cljc", :line 10, :column 1, :end-line 10, :end-column 10, :meta {:file "/Users/dmitry/research/album/resources/public/js/devcards_out/re_frame/subs.cljc", :line 10, :column 6, :end-line 10, :end-column 10}}, query->reaction {:name re-frame.subs/query->reaction, :file "resources/public/js/devcards_out/re_frame/subs.cljc", :line 18, :column 1, :end-line 18, :end-column 21, :meta {:file "/Users/dmitry/research/album/resources/public/js/devcards_out/re_frame/subs.cljc", :line 18, :column 6, :end-line 18, :end-column 21}}, clear-all-handlers! {:protocol-inline nil, :meta {:file "/Users/dmitry/research/album/resources/public/js/devcards_out/re_frame/subs.cljc", :line 20, :column 7, :end-line 20, :end-column 26, :arglists (quote ([])), :doc "Unregisters all existing subscription handlers"}, :name re-frame.subs/clear-all-handlers!, :variadic false, :file "resources/public/js/devcards_out/re_frame/subs.cljc", :end-column 26, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 20, :end-line 20, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Unregisters all existing subscription handlers"}, cache-and-return {:protocol-inline nil, :meta {:file "/Users/dmitry/research/album/resources/public/js/devcards_out/re_frame/subs.cljc", :line 26, :column 7, :end-line 26, :end-column 23, :arglists (quote ([query-v dynv r])), :doc "cache the reaction r"}, :name re-frame.subs/cache-and-return, :variadic false, :file "resources/public/js/devcards_out/re_frame/subs.cljc", :end-column 23, :method-params ([query-v dynv r]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 26, :end-line 26, :max-fixed-arity 3, :fn-var true, :arglists (quote ([query-v dynv r])), :doc "cache the reaction r"}, cache-lookup {:protocol-inline nil, :meta {:file "/Users/dmitry/research/album/resources/public/js/devcards_out/re_frame/subs.cljc", :line 37, :column 7, :end-line 37, :end-column 19, :arglists (quote ([query-v] [query-v dyn-v])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([query-v] [query-v dyn-v]), :arglists ([query-v] [query-v dyn-v]), :arglists-meta (nil nil)}}, :name re-frame.subs/cache-lookup, :variadic false, :file "resources/public/js/devcards_out/re_frame/subs.cljc", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([query-v] [query-v dyn-v]), :arglists ([query-v] [query-v dyn-v]), :arglists-meta (nil nil)}, :method-params ([query-v] [query-v dyn-v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 37, :end-line 37, :max-fixed-arity 2, :fn-var true, :arglists ([query-v] [query-v dyn-v])}, subscribe {:protocol-inline nil, :meta {:file "/Users/dmitry/research/album/resources/public/js/devcards_out/re_frame/subs.cljc", :line 46, :column 7, :end-line 46, :end-column 16, :arglists (quote ([query-v] [v dynv])), :doc "Returns a Reagent/reaction which contains a computation", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([query-v] [v dynv]), :arglists ([query-v] [v dynv]), :arglists-meta (nil nil)}}, :name re-frame.subs/subscribe, :variadic false, :file "resources/public/js/devcards_out/re_frame/subs.cljc", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([query-v] [v dynv]), :arglists ([query-v] [v dynv]), :arglists-meta (nil nil)}, :method-params ([query-v] [v dynv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 46, :end-line 46, :max-fixed-arity 2, :fn-var true, :arglists ([query-v] [v dynv]), :doc "Returns a Reagent/reaction which contains a computation"}, map-vals {:protocol-inline nil, :meta {:file "/Users/dmitry/research/album/resources/public/js/devcards_out/re_frame/subs.cljc", :line 79, :column 8, :end-line 79, :end-column 16, :private true, :arglists (quote ([f m])), :doc "Returns a new version of 'm' in which 'f' has been applied to each value.\n  (map-vals inc {:a 4, :b 2}) => {:a 5, :b 3}"}, :private true, :name re-frame.subs/map-vals, :variadic false, :file "resources/public/js/devcards_out/re_frame/subs.cljc", :end-column 16, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 79, :end-line 79, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m])), :doc "Returns a new version of 'm' in which 'f' has been applied to each value.\n  (map-vals inc {:a 4, :b 2}) => {:a 5, :b 3}"}, deref-input-signals {:protocol-inline nil, :meta {:file "/Users/dmitry/research/album/resources/public/js/devcards_out/re_frame/subs.cljc", :line 88, :column 8, :end-line 88, :end-column 27, :private true, :arglists (quote ([signals query-id]))}, :private true, :name re-frame.subs/deref-input-signals, :variadic false, :file "resources/public/js/devcards_out/re_frame/subs.cljc", :end-column 27, :method-params ([signals query-id]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 88, :end-line 88, :max-fixed-arity 2, :fn-var true, :arglists (quote ([signals query-id]))}, reg-sub {:protocol-inline nil, :meta {:file "/Users/dmitry/research/album/resources/public/js/devcards_out/re_frame/subs.cljc", :line 97, :column 7, :end-line 97, :end-column 14, :arglists (quote ([query-id & args])), :doc "Associate the given `query id` with a handler function and an optional signal function.\n\n  There's 3 ways this function can be called\n\n  1. (reg-sub\n       :test-sub\n       (fn [db [_]] db))\n  The value in app-db is passed to the computation function as the 1st argument.\n\n  2. (reg-sub\n       :a-b-sub\n       (fn [q-vec d-vec]\n         [(subs/subscribe [:a-sub])\n          (subs/subscribe [:b-sub])])\n       (fn [[a b] [_]] {:a a :b b}))\n\n  Two functions provided. The 2nd is computation function, as before. The 1st\n  is returns what `input signals` should be provided to the computation. The\n  `input signals` function is called with two arguments: the query vector\n  and the dynamic vector. The return value can be singleton reaction or\n  a sequence of reactions.\n\n  3. (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))```\n  This 3rd variation is just syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. `:<-` is supplied followed by the subscription\n  vector.\n  ", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(query-id args)], :arglists ([query-id & args]), :arglists-meta (nil)}}, :name re-frame.subs/reg-sub, :variadic true, :file "resources/public/js/devcards_out/re_frame/subs.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(query-id args)], :arglists ([query-id & args]), :arglists-meta (nil)}, :method-params [(query-id args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 97, :end-line 97, :max-fixed-arity 1, :fn-var true, :arglists ([query-id & args]), :doc "Associate the given `query id` with a handler function and an optional signal function.\n\n  There's 3 ways this function can be called\n\n  1. (reg-sub\n       :test-sub\n       (fn [db [_]] db))\n  The value in app-db is passed to the computation function as the 1st argument.\n\n  2. (reg-sub\n       :a-b-sub\n       (fn [q-vec d-vec]\n         [(subs/subscribe [:a-sub])\n          (subs/subscribe [:b-sub])])\n       (fn [[a b] [_]] {:a a :b b}))\n\n  Two functions provided. The 2nd is computation function, as before. The 1st\n  is returns what `input signals` should be provided to the computation. The\n  `input signals` function is called with two arguments: the query vector\n  and the dynamic vector. The return value can be singleton reaction or\n  a sequence of reactions.\n\n  3. (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))```\n  This 3rd variation is just syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. `:<-` is supplied followed by the subscription\n  vector.\n  "}}, :require-macros nil, :cljs.analyzer/constants {:seen #{:else :sub :warn :error}, :order [:sub :error :warn :else]}, :doc nil}